///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#Constant MISS    = 0x7fffffff    // Equal to NaN.
#Constant EPSILON = 0.000001


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// "Point vs Plane" ???
FUNCTION WhichSideOfPlane(Pnt_Pos REF AS Vec3,
                          Pln_Pos REF AS Vec3, Pln_Nrm REF AS Vec3)
    IF dot3(Pln_Nrm, sub3(Pnt_Pos, Pln_Pos)) >= 0.0 THEN EXITFUNCTION 1 // 'Point' is on 'Pln_Nrm' side.
ENDFUNCTION 0 // 'Point' is behind plane.


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// "Infinite-Ray vs Infinite-Plane"
FUNCTION IRayVsIPlane(Ray_Pos REF AS Vec3, Ray_Nrm REF AS Vec3,
                      Pln_Pos REF AS Vec3, Pln_Nrm REF AS Vec3)
    HitPos AS Vec3
    WhichSide AS FLOAT : WhichSide = dot3(Pln_Nrm, sub3(Ray_Pos, Pln_Pos))
    Dot_RayNrm_PlnNrm AS FLOAT : Dot_RayNrm_PlnNrm = -dot3(Ray_Nrm, Pln_Nrm)
    IF WhichSide >= 0.0 : IF (Dot_RayNrm_PlnNrm <  EPSILON) : Print("WhichSide = 1") : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
    ELSE                : IF (Dot_RayNrm_PlnNrm > -EPSILON) : Print("WhichSide = 0") : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
    ENDIF

    // Project Ray onto Plane from Ray_Pos along Ray_Nrm.
    Distance AS FLOAT : Distance = WhichSide / Dot_RayNrm_PlnNrm
    HitPos = add3( Ray_Pos, mul3f(Ray_Nrm, Distance) )
ENDFUNCTION HitPos


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// "Infinite-Ray vs Infinite-Axis-Aligned-Plane"   Plane spans YZ.
FUNCTION IRayVsIAAPlaneX(Ray_Pos REF AS Vec3, Ray_Nrm REF AS Vec3, PlnPosX AS FLOAT)
    HitPos AS Vec3
    Distance AS FLOAT : Distance = (PlnPosX - Ray_Pos.x) / Ray_Nrm.x
    IF (Distance < EPSILON) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
    HitPos = add3( Ray_Pos, mul3f(Ray_Nrm,Distance) )
ENDFUNCTION HitPos


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// "Infinite-Ray vs Infinite-Axis-Aligned-Plane"   Plane spans XZ.
FUNCTION IRayVsIAAPlaneY(Ray_Pos REF AS Vec3, Ray_Nrm REF AS Vec3, PlnPosY AS FLOAT)
    HitPos AS Vec3
    Distance AS FLOAT : Distance = (PlnPosY - Ray_Pos.y) / Ray_Nrm.y
    IF (Distance < EPSILON) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
    HitPos = add3( Ray_Pos, mul3f(Ray_Nrm,Distance) )
ENDFUNCTION HitPos


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// "Infinite-Ray vs Infinite-Axis-Aligned-Plane"   Plane spans XY.
FUNCTION IRayVsIAAPlaneZ(Ray_Pos REF AS Vec3, Ray_Nrm REF AS Vec3, PlnPosZ AS FLOAT)
    HitPos AS Vec3
    Distance AS FLOAT : Distance = (PlnPosZ - Ray_Pos.z) / Ray_Nrm.z
    IF (Distance < EPSILON) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
    HitPos = add3( Ray_Pos, mul3f(Ray_Nrm,Distance) )
ENDFUNCTION HitPos


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// "Point vs Axis-Aligned-Box"
FUNCTION PointVsAab(Pnt_Pos REF AS Vec3, Box_Pos REF AS Vec3, Box_Siz REF AS Vec3)
    IF (Pnt_Pos.x >= Box_Pos.x AND Pnt_Pos.x < Box_Pos.x+Box_Siz.x) AND (Pnt_Pos.y >= Box_Pos.y AND Pnt_Pos.y < Box_Pos.y+Box_Siz.y) AND (Pnt_Pos.z >= Box_Pos.z AND Pnt_Pos.z < Box_Pos.z+Box_Siz.z) THEN EXITFUNCTION 1
ENDFUNCTION 0


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// "Infinite-Ray vs Axis-Aligned-Box"
FUNCTION IRayVsAab(Ray_Pos REF AS Vec3, Ray_Nrm REF AS Vec3, Ray_NrmRecip REF AS Vec3,
                   Box_Pos REF AS Vec3, Box_Siz REF AS Vec3)
    // Distance to bounds Planes from Ray_Pos, for 3 Axes Min & Max, 6 total.
    DistMinX AS FLOAT : DistMinX = (Box_Pos.x             - Ray_Pos.x) * Ray_NrmRecip.x  // We can avoid div here by using (1.0 / RayNormal).
    DistMaxX AS FLOAT : DistMaxX = (Box_Pos.x + Box_Siz.x - Ray_Pos.x) * Ray_NrmRecip.x
    DistMinY AS FLOAT : DistMinY = (Box_Pos.y             - Ray_Pos.y) * Ray_NrmRecip.y
    DistMaxY AS FLOAT : DistMaxY = (Box_Pos.y + Box_Siz.y - Ray_Pos.y) * Ray_NrmRecip.y
    DistMinZ AS FLOAT : DistMinZ = (Box_Pos.z             - Ray_Pos.z) * Ray_NrmRecip.z
    DistMaxZ AS FLOAT : DistMaxZ = (Box_Pos.z + Box_Siz.z - Ray_Pos.z) * Ray_NrmRecip.z

    //       +Y  |      |
    //           |      |                                          +Y -Z (far)
    //       ----+------+---- <-- DistMaxY                          | /
    //           |      |                                           |/
    //           |      |                           DistMinZ -->    +---- +X
    //           |      |                                          /
    //       ----+------+---- <-- DistMinY                        /
    //           |      |                                        /
    //       0   |      |  +X                   DistMaxZ -->   +Z (near)
    //           ^
    //        DistMinX  ^
    //               DistMaxX

    // Reorient Min<-->Max relative to Ray_Pos.
    HoldMe AS FLOAT
    IF (DistMinX > DistMaxX) : HoldMe = DistMinX : DistMinX = DistMaxX : DistMaxX = HoldMe : ENDIF // max(DistMinX, DistMaxX)
    IF (DistMinY > DistMaxY) : HoldMe = DistMinY : DistMinY = DistMaxY : DistMaxY = HoldMe : ENDIF // max(DistMinY, DistMaxY)
    IF (DistMinZ > DistMaxZ) : HoldMe = DistMinZ : DistMinZ = DistMaxZ : DistMaxZ = HoldMe : ENDIF // max(DistMinZ, DistMaxZ)

    // Select PlaneHits in Quadrant/Octant of Box.
    DistFront AS FLOAT
    IF DistMinX > DistMinY // max(DistMinX, DistMinY)
        IF (DistMinX > DistMinZ) : DistFront = DistMinX : ELSE : DistFront = DistMinZ : ENDIF // max(DistMinX, DistMinZ)
    ELSE
        IF (DistMinY > DistMinZ) : DistFront = DistMinY : ELSE : DistFront = DistMinZ : ENDIF // max(DistMinY, DistMinZ)
    ENDIF
    DistBack AS FLOAT
    IF DistMaxX < DistMaxY // min(DistMaxX, DistMaxY)
        IF (DistMaxX < DistMaxZ) : DistBack = DistMaxX : ELSE : DistBack = DistMaxZ : ENDIF // min(DistMaxX, DistMaxZ)
    ELSE
        IF (DistMaxY < DistMaxZ) : DistBack = DistMaxY : ELSE : DistBack = DistMaxZ : ENDIF // min(DistMaxY, DistMaxZ)
    ENDIF

    // Did we hit it?
    HitPos AS Vec3
    IF     (DistBack  <      0.0) : HitPos.x = MISS // Box is behind us.
    ELSEIF (DistFront > DistBack) : HitPos.x = MISS // Ray does not collide.
    ELSE                          : HitPos   = add3( Ray_Pos, mul3f(Ray_Nrm,DistFront) ) // Get HitPosition.
    ENDIF
ENDFUNCTION HitPos


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION RayVsTriangle(Ray_Pos REF AS Vec3, Ray_Nrm REF AS Vec3, RayLen AS FLOAT, TriVrt AS Vec3[], BackFaceTest AS INTEGER)
  //TriVrt[0] = TriVrt[0]
    TriVrt[1] = sub3(TriVrt[1], TriVrt[0])  // TriVrt1 In TriangleSpace.
    TriVrt[2] = sub3(TriVrt[2], TriVrt[0])  // TriVrt2 In TriangleSpace.

    TriNrm      AS Vec3 : TriNrm      = crs3(TriVrt[1], TriVrt[2])
    RayPosLocal AS Vec3 : RayPosLocal = sub3(TriVrt[0], Ray_Pos)  // Ray_Pos In TriangleSpace.
    Crs_RPL_RN  AS Vec3 : Crs_RPL_RN  = crs3(RayPosLocal, Ray_Nrm)

    Dtrmnt AS FLOAT : Dtrmnt = dot3(Ray_Nrm, TriNrm)  // "Determinant".

    Dot_CrsRPLRN_V2 AS FLOAT
    Dot_CrsRPLRN_V1 AS FLOAT
    Dot_RPL_TN  AS FLOAT
    IF Dtrmnt >= 0.0
        IF NOT BackFaceTest : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
        Dot_CrsRPLRN_V2 =  dot3(Crs_RPL_RN,  TriVrt[2]) : IF (Dot_CrsRPLRN_V2 < 0.0 OR Dot_CrsRPLRN_V2                   >        Dtrmnt                    ) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
        Dot_CrsRPLRN_V1 = -dot3(Crs_RPL_RN,  TriVrt[1]) : IF (Dot_CrsRPLRN_V1 < 0.0 OR Dot_CrsRPLRN_V2 + Dot_CrsRPLRN_V1 >        Dtrmnt                    ) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
        Dot_RPL_TN      =  dot3(RayPosLocal, TriNrm)    : IF (Dot_RPL_TN      < 0.0 OR Dot_RPL_TN                        > RayLen*Dtrmnt OR Dtrmnt < EPSILON) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
    ELSE
        Dot_CrsRPLRN_V2 =  dot3(Crs_RPL_RN,  TriVrt[2]) : IF (Dot_CrsRPLRN_V2 > 0.0 OR Dot_CrsRPLRN_V2                   <        Dtrmnt                    ) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
        Dot_CrsRPLRN_V1 = -dot3(Crs_RPL_RN,  TriVrt[1]) : IF (Dot_CrsRPLRN_V1 > 0.0 OR Dot_CrsRPLRN_V2 + Dot_CrsRPLRN_V1 <        Dtrmnt                    ) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
        Dot_RPL_TN      =  dot3(RayPosLocal, TriNrm)    : IF (Dot_RPL_TN      > 0.0 OR Dot_RPL_TN                        < RayLen*Dtrmnt                    ) : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
    ENDIF

    HitPos AS Vec3
  //DtrmntRcp = 1.0 / Dtrmnt
  //HitDist   = Dot_RPL_TN * DtrmntRcp
    HitPos = add3(    Ray_Pos, mul3f( Ray_Nrm, Dot_RPL_TN * (1.0/Dtrmnt) )    )
ENDFUNCTION HitPos


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION RayVsTriMesh(Ray_Pos REF AS Vec3, Ray_Nrm REF AS Vec3, RayLen AS FLOAT, TriMesh REF AS Vec3[], BackFaceTest AS INTEGER)

    // Option to stop at first Hit,
    // or to register all hits, then return closest hit,
    // or return all hits sorted in order?

    Hits   AS Vec3[]
    HitPos AS Vec3

////  //TriVrt[0] = TriVrt[0]
////    TriVrt[1] = sub3(TriVrt[1], TriVrt[0])  // TriVrt1 In TriangleSpace.
////    TriVrt[2] = sub3(TriVrt[2], TriVrt[0])  // TriVrt2 In TriangleSpace.
////
////    TriNrm      AS Vec3 : TriNrm      = crs3(TriVrt[1], TriVrt[2])
////    RayPosLocal AS Vec3 : RayPosLocal = sub3(TriVrt[0], Ray_Pos)  // Ray_Pos In TriangleSpace.
////    Crs_RPL_RN  AS Vec3 : Crs_RPL_RN  = crs3(RayPosLocal, Ray_Nrm)
////
////    Dtrmnt AS FLOAT : Dtrmnt = dot3(Ray_Nrm, TriNrm)  // Determinant.
////
////    Dot_CrsRPLRN_V2 AS FLOAT
////    Dot_CrsRPLRN_V1 AS FLOAT
////    Dot_RPL_TN  AS FLOAT
////    IF Dtrmnt >= 0.0
////        IF NOT BackFaceTest : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
////        Dot_CrsRPLRN_V2 =  dot3(Crs_RPL_RN,  TriVrt[2]) : IF Dot_CrsRPLRN_V2 < 0.0 OR Dot_CrsRPLRN_V2                   > Dtrmnt      : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
////        Dot_CrsRPLRN_V1 = -dot3(Crs_RPL_RN,  TriVrt[1]) : IF Dot_CrsRPLRN_V1 < 0.0 OR Dot_CrsRPLRN_V2 + Dot_CrsRPLRN_V1 > Dtrmnt      : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
////        Dot_RPL_TN      =  dot3(RayPosLocal, TriNrm)    : IF Dot_RPL_TN      < 0.0 OR Dot_RPL_TN  > RayLen*Dtrmnt OR Dtrmnt < EPSILON : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
////    ELSE
////        Dot_CrsRPLRN_V2 =  dot3(Crs_RPL_RN,  TriVrt[2]) : IF Dot_CrsRPLRN_V2 > 0.0 OR Dot_CrsRPLRN_V2                   < Dtrmnt      : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
////        Dot_CrsRPLRN_V1 = -dot3(Crs_RPL_RN,  TriVrt[1]) : IF Dot_CrsRPLRN_V1 > 0.0 OR Dot_CrsRPLRN_V2 + Dot_CrsRPLRN_V1 < Dtrmnt      : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
////        Dot_RPL_TN      =  dot3(RayPosLocal, TriNrm)    : IF Dot_RPL_TN      > 0.0 OR Dot_RPL_TN  < RayLen*Dtrmnt                     : HitPos.x = MISS : EXITFUNCTION HitPos : ENDIF
////    ENDIF
////
////    // DtrmntRcp = 1.0 / Dtrmnt
////    // HitDist   = Dot_RPL_TN * DtrmntRcp
////    HitPos = add3(    Ray_Pos, mul3f( Ray_Nrm, Dot_RPL_TN * (1.0/Dtrmnt) )    )

ENDFUNCTION HitPos


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION PointVsSphere(Pnt_Pos REF AS Vec3,
                       Sph_Pos REF AS Vec3, Sph_Rds AS FLOAT)

    Delta_X  AS FLOAT : Delta_X  = Sph_Pos.x - Pnt_Pos.x
    Delta_Y  AS FLOAT : Delta_Y  = Sph_Pos.y - Pnt_Pos.y
    Distance AS FLOAT : Distance = Sph_Pos.z - Pnt_Pos.z // "Delta_Z".

    Distance = sqrt(Delta_X*Delta_X + Delta_Y*Delta_Y + Distance*Distance)

    IF Distance <= Sph_Rds THEN EXITFUNCTION 1

ENDFUNCTION 0


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION IRayVsSphere(Ray_Pos REF AS Vec3, Ray_Nrm REF AS Vec3,
                      Sph_Pos REF AS Vec3, Sph_Rds AS FLOAT)

    HitPos AS Vec3

    //  Is Ray_Pos inside the Sphere?
    //      HitPos = Ray_Pos

    //  Project Sph_Pos onto Ray-Line, is this point inside the Sphere?
    //      Then, determine HitPos...
    //          HitPos = ...

ENDFUNCTION HitPos

