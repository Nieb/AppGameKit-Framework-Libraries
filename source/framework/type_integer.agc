///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION sign(SignMe AS INTEGER)
    IF     SignMe > 0 : EXITFUNCTION  1
    ELSEIF SignMe < 0 : EXITFUNCTION -1
    ENDIF
ENDFUNCTION 0


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION min(IntA AS INTEGER, IntB AS INTEGER) : IF IntA < IntB THEN EXITFUNCTION IntA : ENDFUNCTION IntB
FUNCTION max(IntA AS INTEGER, IntB AS INTEGER) : IF IntA > IntB THEN EXITFUNCTION IntA : ENDFUNCTION IntB


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION clamp(ClampMe AS INTEGER, ClampMin AS INTEGER, ClampMax AS INTEGER)
    IF     ClampMe < ClampMin : EXITFUNCTION ClampMin
    ELSEIF ClampMe > ClampMax : EXITFUNCTION ClampMax
    ENDIF
ENDFUNCTION ClampMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION wrap(WrapMe AS INTEGER, WrapMin AS INTEGER, WrapMax AS INTEGER)
    IF (WrapMe >= WrapMin AND WrapMe < WrapMax) THEN EXITFUNCTION WrapMe
    WrapMe  = WrapMe  - WrapMin
    WrapMax = WrapMax - WrapMin
    IF     (WrapMe <      0.0) : WrapMe = WrapMin + WrapMax + mod( WrapMe, WrapMax)
    ELSEIF (WrapMe >= WrapMax) : WrapMe = WrapMin +           mod( WrapMe, WrapMax)
    ENDIF
ENDFUNCTION WrapMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCTION CountTowards( CountFrom AS INTEGER, CountTo AS INTEGER)
//    IF CountFrom = CountTo THEN EXITFUNCTION CountTo
//    CountNew AS INTEGER
//    IF CountFrom < CountTo : CountNew = CountFrom +  ceil((CountTo - CountFrom) * (0.07 * Time.Multiplier)) // Count Up
//    ELSE                   : CountNew = CountFrom + floor((CountTo - CountFrom) * (0.07 * Time.Multiplier)) // Count Down
//    ENDIF
//ENDFUNCTION CountNew

