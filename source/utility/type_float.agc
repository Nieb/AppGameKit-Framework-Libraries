///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Float 32 bit  --  IEEE-754 Floating Point
//  https://www.h-schmidt.net/FloatConverter/IEEE754.html
//  https://www.ibm.com/docs/en/xcafbg/9.0.0?topic=SS3KZ4_9.0.0/com.ibm.xlf111.bg.doc/xlfopg/fpieee.htm
#Constant FLT_NaN     = 0x7fffffff

#Constant FLT_Inf     = 0x7f800000
#Constant FLT_InfNeg  = 0xff800000

#Constant FLT_ZeroNeg = 0x80000000


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION flt(Int AS FLOAT) : ENDFUNCTION Int  // For explicit casting.


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION Print1(Label AS STRING, PrintMe AS FLOAT, PadLeft AS INTEGER, TruncRight AS INTEGER)
    Print( Label + padstr(PrintMe, PadLeft, TruncRight) )
ENDFUNCTION


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION signf(SignMe AS FLOAT)
    IF     (SignMe > 0.0) : EXITFUNCTION  1.0
    ELSEIF (SignMe < 0.0) : EXITFUNCTION -1.0
    ENDIF
ENDFUNCTION 0.0


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION minf(FltA AS FLOAT, FltB AS FLOAT) : IF (FltA < FltB) THEN EXITFUNCTION FltA : ENDFUNCTION FltB
FUNCTION maxf(FltA AS FLOAT, FltB AS FLOAT) : IF (FltA > FltB) THEN EXITFUNCTION FltA : ENDFUNCTION FltB


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION clampf(ClampMe AS FLOAT, ClampMin AS FLOAT, ClampMax AS FLOAT)
    IF     (ClampMe < ClampMin) : EXITFUNCTION ClampMin
    ELSEIF (ClampMe > ClampMax) : EXITFUNCTION ClampMax
    ENDIF
ENDFUNCTION ClampMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION wrapf(WrapMe AS FLOAT, WrapMin AS FLOAT, WrapMax AS FLOAT)
    IF (WrapMe >= WrapMin AND WrapMe < WrapMax) THEN EXITFUNCTION WrapMe
    WrapMe  = WrapMe  - WrapMin
    WrapMax = WrapMax - WrapMin
    IF     (WrapMe <      0.0) : WrapMe = WrapMin + WrapMax + fmod( WrapMe, WrapMax)
    ELSEIF (WrapMe >= WrapMax) : WrapMe = WrapMin +           fmod( WrapMe, WrapMax)
    ENDIF
ENDFUNCTION WrapMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rndto(RoundMe AS FLOAT, RoundTo AS FLOAT)
    ModMe AS FLOAT : ModMe = fmod(RoundMe, RoundTo)
    IF     (ModMe > 0.0) : IF (ModMe >  RoundTo*0.5) : RoundMe = RoundMe + (RoundTo -     ModMe ) : ELSE : RoundMe = RoundMe -     ModMe  : ENDIF
    ELSEIF (ModMe < 0.0) : IF (ModMe < -RoundTo*0.5) : RoundMe = RoundMe - (RoundTo - abs(ModMe)) : ELSE : RoundMe = RoundMe + abs(ModMe) : ENDIF
    ENDIF
ENDFUNCTION RoundMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Hyperbolic Trigonometric Functions:         https://en.wikipedia.org/wiki/Hyperbolic_functions
FUNCTION cosh(X AS FLOAT) : ENDFUNCTION (Euler^X + Euler^-X) / 2.0 // X = Radians, returns Y.

FUNCTION sinh(X AS FLOAT) : ENDFUNCTION (Euler^X - Euler^-X) / 2.0 // X = Radians, returns Y.

FUNCTION tanh(X AS FLOAT) // X = Radians, returns Y.
    //  With Float32:
    //      IF X  =  8.3  THEN Y = 0.999_999_8~~
    //      IF X  =  8.33 THEN Y = 1.0
    //      IF X >= 88.8  THEN Y = -nan(ind)
    IF     X >  8.4 : EXITFUNCTION  1.0
    ELSEIF X < -8.4 : EXITFUNCTION -1.0
    ELSE
        Euler_X  AS FLOAT : Euler_X  = Euler^X
        Euler_nX AS FLOAT : Euler_nX = Euler^-X
        EXITFUNCTION (Euler_X - Euler_nX) / (Euler_X + Euler_nX)
    ENDIF
ENDFUNCTION 0.0


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION Sigmoid(X AS FLOAT) : ENDFUNCTION 1.0 / (1.0 + Euler^-X) // Returns Y.


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sigmoid centered at (0,0).       https://www.desmos.com/calculator/b6f0ca1hhh
FUNCTION Sigmoidish(X    AS FLOAT,
                    PosX AS FLOAT, PosY AS FLOAT, // "Position"
                    SclX AS FLOAT, SclY AS FLOAT) // "Scale"
ENDFUNCTION PosY - 1.0 + (  SclY / (1.0 + (Euler^(-X*SclX)) * (Euler^(PosX*SclX)))  )

