///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Float 32 bit  --  IEEE-754 Floating Point
//  https://www.h-schmidt.net/FloatConverter/IEEE754.html
//  https://www.ibm.com/docs/en/xcafbg/9.0.0?topic=SS3KZ4_9.0.0/com.ibm.xlf111.bg.doc/xlfopg/fpieee.htm
GLOBAL FLT_NaN     AS FLOAT //#Constant FLT_NaN     = 0x7fffffff
GLOBAL FLT_Inf     AS FLOAT //#Constant FLT_Inf     = 0x7f800000
GLOBAL FLT_InfNeg  AS FLOAT //#Constant FLT_InfNeg  = 0xff800000
GLOBAL FLT_ZeroNeg AS FLOAT //#Constant FLT_ZeroNeg = 0x80000000


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  For explicit casting:
FUNCTION flt(Int AS FLOAT) : ENDFUNCTION Int


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION InitializeFloat()
    TempBlock AS INTEGER : TempBlock = CreateMemblock(16)
    SetMemblockInt(TempBlock, 0, 0x7fffffff)
    SetMemblockInt(TempBlock, 4, 0x7f800000)
    SetMemblockInt(TempBlock, 8, 0xff800000)
    SetMemblockInt(TempBlock,12, 0x80000000)

    FLT_NaN     = GetMemblockFloat(TempBlock,  0)
    FLT_Inf     = GetMemblockFloat(TempBlock,  4)
    FLT_InfNeg  = GetMemblockFloat(TempBlock,  8)
    FLT_ZeroNeg = GetMemblockFloat(TempBlock, 12)

    DeleteMemblock(TempBlock)
ENDFUNCTION


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION Print1(Label AS STRING, PrintMe AS FLOAT, PadLeft AS INTEGER, TruncRight AS INTEGER)
    Print( Label + padstr(PrintMe, PadLeft, TruncRight) )
ENDFUNCTION


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// "Average" of # FLOATs
FUNCTION avgf_2(FltA AS FLOAT, FltB AS FLOAT)                               : ENDFUNCTION (FltA + FltB) * 0.5
FUNCTION avgf_3(FltA AS FLOAT, FltB AS FLOAT, FltC AS FLOAT)                : ENDFUNCTION (FltA + FltB + FltC) * OneThird
FUNCTION avgf_4(FltA AS FLOAT, FltB AS FLOAT, FltC AS FLOAT, FltD AS FLOAT) : ENDFUNCTION (FltA + FltB + FltC + FltD) * 0.25


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION clampf(ClampMe AS FLOAT, ClampMin AS FLOAT, ClampMax AS FLOAT)
    IF     (ClampMe < ClampMin) : EXITFUNCTION ClampMin
    ELSEIF (ClampMe > ClampMax) : EXITFUNCTION ClampMax
    ENDIF
ENDFUNCTION ClampMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION wrapf(WrapMe AS FLOAT, WrapMin AS FLOAT, WrapMax AS FLOAT)
    IF (WrapMe >= WrapMin AND WrapMe < WrapMax) THEN EXITFUNCTION WrapMe
    WrapMe  = WrapMe  - WrapMin
    WrapMax = WrapMax - WrapMin
    IF     (WrapMe <      0.0) : WrapMe = WrapMin + WrapMax + fmod( WrapMe, WrapMax)
    ELSEIF (WrapMe >= WrapMax) : WrapMe = WrapMin +           fmod( WrapMe, WrapMax)
    ENDIF
ENDFUNCTION WrapMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION minf(FltA AS FLOAT, FltB AS FLOAT) : IF (FltA < FltB) THEN EXITFUNCTION FltA : ENDFUNCTION FltB
FUNCTION maxf(FltA AS FLOAT, FltB AS FLOAT) : IF (FltA > FltB) THEN EXITFUNCTION FltA : ENDFUNCTION FltB


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rndto(RoundMe AS FLOAT, RoundTo AS FLOAT)
    ModMe AS FLOAT : ModMe = fmod(RoundMe, RoundTo)
    IF     (ModMe > 0.0) : IF (ModMe >  RoundTo*0.5) : RoundMe = RoundMe + (RoundTo -     ModMe ) : ELSE : RoundMe = RoundMe -     ModMe  : ENDIF
    ELSEIF (ModMe < 0.0) : IF (ModMe < -RoundTo*0.5) : RoundMe = RoundMe - (RoundTo - abs(ModMe)) : ELSE : RoundMe = RoundMe + abs(ModMe) : ENDIF
    ENDIF
ENDFUNCTION RoundMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION signf(SignMe AS FLOAT)
    IF     (SignMe > 0.0) : EXITFUNCTION  1.0
    ELSEIF (SignMe < 0.0) : EXITFUNCTION -1.0
    ENDIF
ENDFUNCTION 0.0

