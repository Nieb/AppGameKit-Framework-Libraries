///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#Constant INT_Min = 0x80000000 // -2,147,483,648
#Constant INT_Max = 0x7FFFFFFF //  2,147,483,647


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION clamp(ClampMe AS INTEGER, ClampMin AS INTEGER, ClampMax AS INTEGER)
    IF     (ClampMe < ClampMin) : EXITFUNCTION ClampMin
    ELSEIF (ClampMe > ClampMax) : EXITFUNCTION ClampMax
    ENDIF
ENDFUNCTION ClampMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION wrap(WrapMe AS INTEGER, WrapMin AS INTEGER, WrapMax AS INTEGER)
    IF (WrapMe >= WrapMin AND WrapMe < WrapMax) THEN EXITFUNCTION WrapMe
    WrapMe  = WrapMe  - WrapMin
    WrapMax = WrapMax - WrapMin
    IF     (WrapMe <        0) : WrapMe = WrapMin + WrapMax + mod( WrapMe, WrapMax)
    ELSEIF (WrapMe >= WrapMax) : WrapMe = WrapMin +           mod( WrapMe, WrapMax)
    ENDIF
ENDFUNCTION WrapMe


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION min(IntA AS INTEGER, IntB AS INTEGER) : IF (IntA < IntB) THEN EXITFUNCTION IntA : ENDFUNCTION IntB
FUNCTION max(IntA AS INTEGER, IntB AS INTEGER) : IF (IntA > IntB) THEN EXITFUNCTION IntA : ENDFUNCTION IntB


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION sign(SignMe AS INTEGER)
    IF     (SignMe > 0) : EXITFUNCTION  1
    ELSEIF (SignMe < 0) : EXITFUNCTION -1
    ENDIF
ENDFUNCTION 0  //@@ Do we really want 0 if 0?


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCTION CountTowards( CountFrom AS INTEGER, CountTo AS INTEGER)
//    IF CountFrom = CountTo THEN EXITFUNCTION CountTo
//    CountNew AS INTEGER
//    IF CountFrom < CountTo : CountNew = CountFrom +  ceil((CountTo - CountFrom) * (0.07 * Time.Multiplier)) // Count Up.
//    ELSE                   : CountNew = CountFrom + floor((CountTo - CountFrom) * (0.07 * Time.Multiplier)) // Count Down.
//    ENDIF
//ENDFUNCTION CountNew

