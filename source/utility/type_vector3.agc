///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TYPE Vec3
    x AS FLOAT
    y AS FLOAT
    z AS FLOAT
ENDTYPE

TYPE iVec3
    x AS INTEGER
    y AS INTEGER
    z AS INTEGER
ENDTYPE


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION vec3(FltX AS FLOAT, FltY AS FLOAT, FltZ AS FLOAT)
    Result AS Vec3
    Result.x = FltX
    Result.y = FltY
    Result.z = FltZ
ENDFUNCTION Result

FUNCTION ivec3(IntX AS INTEGER, IntY AS INTEGER, IntZ AS INTEGER)
    Result AS iVec3
    Result.x = IntX
    Result.y = IntY
    Result.z = IntZ
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION InitializeVector3()
    // AGK does not support default values for UserTypes nor UserType Constants.
    GLOBAL Zero3     AS Vec3 : Zero3     = vec3(0.0, 0.0, 0.0)
    GLOBAL Axis3_X   AS Vec3 : Axis3_X   = vec3(1.0, 0.0, 0.0)
    GLOBAL Axis3_Y   AS Vec3 : Axis3_Y   = vec3(0.0, 1.0, 0.0)
    GLOBAL Axis3_Z   AS Vec3 : Axis3_Z   = vec3(0.0, 0.0, 1.0)

    GLOBAL Axis3_XY  AS Vec3 : Axis3_XY  = vec3(Sqrt2Rcp, Sqrt2Rcp,      0.0)
    GLOBAL Axis3_YZ  AS Vec3 : Axis3_YZ  = vec3(     0.0, Sqrt2Rcp, Sqrt2Rcp)
    GLOBAL Axis3_ZX  AS Vec3 : Axis3_ZX  = vec3(Sqrt2Rcp,      0.0, Sqrt2Rcp)

    GLOBAL Axis3_XYZ AS Vec3 : Axis3_XYZ = vec3(Sqrt3Rcp, Sqrt3Rcp, Sqrt3Rcp)
ENDFUNCTION


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION Print3(Label AS STRING, PrintMe REF AS Vec3, PadLeft AS INTEGER, TruncRight AS INTEGER)
    Print(Label + padstr(PrintMe.x, PadLeft, TruncRight)+" "+padstr(PrintMe.y, PadLeft, TruncRight)+" "+padstr(PrintMe.z, PadLeft, TruncRight))
ENDFUNCTION


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION add3(VecA REF AS Vec3, VecB REF AS Vec3) // 'VecA' + 'VecB'
    Result AS Vec3
    Result.x = VecA.x + VecB.x
    Result.y = VecA.y + VecB.y
    Result.z = VecA.z + VecB.z
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION add3f(VecA REF AS Vec3, FltA AS FLOAT) // 'VecA' + 'FltA'
    Result AS Vec3
    Result.x = VecA.x + FltA
    Result.y = VecA.y + FltA
    Result.z = VecA.z + FltA
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION sub3(VecA REF AS Vec3, VecB REF AS Vec3) // 'VecA' - 'VecB'
    Result AS Vec3
    Result.x = VecA.x - VecB.x
    Result.y = VecA.y - VecB.y
    Result.z = VecA.z - VecB.z
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION sub3f(VecA REF AS Vec3, FltA AS FLOAT) // 'VecA' - 'FltA'
    Result AS Vec3
    Result.x = VecA.x - FltA
    Result.y = VecA.y - FltA
    Result.z = VecA.z - FltA
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION mul3(VecA REF AS Vec3, VecB REF AS Vec3) // 'VecA' * 'VecB'
    Result AS Vec3
    Result.x = VecA.x * VecB.x
    Result.y = VecA.y * VecB.y
    Result.z = VecA.z * VecB.z
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION mul3f(VecA REF AS Vec3, FltA AS FLOAT) // 'VecA' * 'FltA'
    Result AS Vec3
    Result.x = VecA.x * FltA
    Result.y = VecA.y * FltA
    Result.z = VecA.z * FltA
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION div3(VecA REF AS Vec3, VecB REF AS Vec3) // 'VecA' / 'VecB'
    Result AS Vec3
    Result.x = VecA.x / VecB.x
    Result.y = VecA.y / VecB.y
    Result.z = VecA.z / VecB.z
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION div3f(VecA REF AS Vec3, FltA AS FLOAT) // 'VecA' / 'FltA'
    Result AS Vec3
    Result.x = VecA.x / FltA
    Result.y = VecA.y / FltA
    Result.z = VecA.z / FltA
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION dot3(VecA REF AS Vec3, VecB REF AS Vec3) // 'VecA' dot 'VecB'
    Result AS FLOAT
    Result = (VecA.x * VecB.x) + (VecA.y * VecB.y) + (VecA.z * VecB.z)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION crs3(VecA REF AS Vec3, VecB REF AS Vec3) // 'VecA' cross 'VecB'
    Result AS Vec3
    Result.x = (VecA.y * VecB.z) - (VecA.z * VecB.y)
    Result.y = (VecA.z * VecB.x) - (VecA.x * VecB.z)
    Result.z = (VecA.x * VecB.y) - (VecA.y * VecB.x)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION inv3(VecA REF AS Vec3) // "Invert" (Additive Inverse) 'VecA'.
    Result AS Vec3
    Result.x = -VecA.x
    Result.y = -VecA.y
    Result.z = -VecA.z
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION cmp3(VecA REF AS Vec3) // "Complement" (Complimentary Inverse) of 'VecA'.
    Result AS Vec3
    Result.x = 1.0 - VecA.x
    Result.y = 1.0 - VecA.y
    Result.z = 1.0 - VecA.z
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rcp3(VecA REF AS Vec3) // "Reciprocal" (Multiplicative Inverse) of 'VecA'.
    Result AS Vec3
    Result.x = 1.0 / VecA.x
    Result.y = 1.0 / VecA.y
    Result.z = 1.0 / VecA.z
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION len3(VecA REF AS Vec3) // "Length" of 'VecA'. (Distance from (0,0,0))
    Result AS FLOAT : Result = sqrt(VecA.x*VecA.x + VecA.y*VecA.y + VecA.z*VecA.z)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION dst3(VecA AS Vec3, VecB AS Vec3) // "Distance" between 'VecA' and 'VecB'.
    Delta_X AS FLOAT : Delta_X = VecB.x - VecA.x
    Delta_Y AS FLOAT : Delta_Y = VecB.y - VecA.y
    Result  AS FLOAT : Result  = VecB.z - VecA.z // "Delta_Z"
    Result = sqrt((Delta_X*Delta_X) + (Delta_Y*Delta_Y) + (Result*Result))
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION lenthn3(VecA REF AS Vec3, NewLength AS FLOAT) // "Lengthen"  'VecA' scaled to 'NewLength'.
    Result AS Vec3
    IF (VecA.x = 0.0 AND VecA.y = 0.0 AND VecA.z = 0.0) // Avoid Divide-by-Zero.
        Result.x = 0.0
        Result.y = 0.0
        Result.z = 0.0
    ELSE
        NewLength = NewLength / sqrt(VecA.x*VecA.x + VecA.y*VecA.y + VecA.z*VecA.z) // Get Vector Scaler (LengthNew / LengthOld).
        Result.x = VecA.x * NewLength
        Result.y = VecA.y * NewLength
        Result.z = VecA.z * NewLength
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION nrm3(VecA REF AS Vec3) // "Normalize"  'VecA' scaled to length of 1.0.
    Result AS Vec3
    IF (VecA.x = 0.0 AND VecA.y = 0.0 AND VecA.z = 0.0) // Avoid Divide-by-Zero.
        Result.x = 0.0
        Result.y = 0.0
        Result.z = 0.0
    ELSE
        Length AS FLOAT : Length = 1.0 / sqrt(VecA.x*VecA.x + VecA.y*VecA.y + VecA.z*VecA.z) // Get Vector Scaler (LengthNew / LengthOld).
        Result.x = VecA.x * Length
        Result.y = VecA.y * Length
        Result.z = VecA.z * Length
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION flr3(VecA REF AS Vec3) // "Floor"  Each component of 'VecA' rounded down.
    Result AS Vec3
    Result.x = floor(VecA.x)
    Result.y = floor(VecA.y)
    Result.z = floor(VecA.z)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION cil3(VecA REF AS Vec3) // "Ceiling"  Each component of 'VecA' rounded up.
    Result AS Vec3
    Result.x = ceil(VecA.x)
    Result.y = ceil(VecA.y)
    Result.z = ceil(VecA.z)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rnd3(VecA REF AS Vec3) // "Round" each component of 'VecA' to nearest Integer.
    Result AS Vec3
    Result.x = round(VecA.x)
    Result.y = round(VecA.y)
    Result.z = round(VecA.z)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rndto3(VecA REF AS Vec3, RoundTo AS FLOAT) // "Round" each component of 'VecA' to nearest multiple of 'RoundTo'.
    Result AS Vec3
    Result.x = fmod(VecA.x, RoundTo)
    Result.y = fmod(VecA.y, RoundTo)
    Result.z = fmod(VecA.z, RoundTo)
    Threshold AS FLOAT : Threshold = RoundTo * 0.5
    IF     (Result.x > 0.0) : IF (Result.x >=  Threshold) : Result.x = VecA.x + RoundTo -     Result.x  : ELSE : Result.x = VecA.x -     Result.x  : ENDIF
    ELSEIF (Result.x < 0.0) : IF (Result.x <= -Threshold) : Result.x = VecA.x - RoundTo + abs(Result.x) : ELSE : Result.x = VecA.x + abs(Result.x) : ENDIF
    ELSE                                                  : Result.x = VecA.x
    ENDIF
    IF     (Result.y > 0.0) : IF (Result.y >=  Threshold) : Result.y = VecA.y + RoundTo -     Result.y  : ELSE : Result.y = VecA.y -     Result.y  : ENDIF
    ELSEIF (Result.y < 0.0) : IF (Result.y <= -Threshold) : Result.y = VecA.y - RoundTo + abs(Result.y) : ELSE : Result.y = VecA.y + abs(Result.y) : ENDIF
    ELSE                                                  : Result.y = VecA.y
    ENDIF
    IF     (Result.z > 0.0) : IF (Result.z >=  Threshold) : Result.z = VecA.z + RoundTo -     Result.z  : ELSE : Result.z = VecA.z -     Result.z  : ENDIF
    ELSEIF (Result.z < 0.0) : IF (Result.z <= -Threshold) : Result.z = VecA.z - RoundTo + abs(Result.z) : ELSE : Result.z = VecA.z + abs(Result.z) : ENDIF
    ELSE                                                  : Result.z = VecA.z
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION avg3_2(VecA REF AS Vec3, VecB REF AS Vec3) // "Average" of 2 Vectors.
    Result AS Vec3
    Result.x = (VecA.x + VecB.x) * 0.5
    Result.y = (VecA.y + VecB.y) * 0.5
    Result.z = (VecA.z + VecB.z) * 0.5
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION avg3_3(VecA REF AS Vec3, VecB REF AS Vec3, VecC REF AS Vec3) // "Average" of 3 Vectors.
    Result AS Vec3
    Result.x = (VecA.x + VecB.x + VecC.x) * OneThird
    Result.y = (VecA.y + VecB.y + VecC.y) * OneThird
    Result.z = (VecA.z + VecB.z + VecC.z) * OneThird
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION avg3_4(VecA REF AS Vec3, VecB REF AS Vec3, VecC REF AS Vec3, VecD REF AS Vec3) // "Average" of 4 Vectors.
    Result AS Vec3
    Result.x = (VecA.x + VecB.x + VecC.x + VecD.x) * 0.25
    Result.y = (VecA.y + VecB.y + VecC.y + VecD.y) * 0.25
    Result.z = (VecA.z + VecB.z + VecC.z + VecD.z) * 0.25
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION ref3(VecA REF AS Vec3, SurfaceNrm REF AS Vec3) // "Reflect"   //@@ fix: Add Multiplier?
    Dot AS FLOAT : Dot = (VecA.x * SurfaceNrm.x) + (VecA.y * SurfaceNrm.y) + (VecA.z * SurfaceNrm.z)
    Result AS Vec3
    Result.x = VecA.x + (SurfaceNrm.x * Dot * -2.0)
    Result.y = VecA.y + (SurfaceNrm.y * Dot * -2.0)
    Result.z = VecA.z + (SurfaceNrm.z * Dot * -2.0)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION def3(VecA REF AS Vec3, SurfaceNrm REF AS Vec3) // "Deflect"   //@@ fix: Add Multiplier?
    Dot AS FLOAT : Dot = (VecA.x * SurfaceNrm.x) + (VecA.y * SurfaceNrm.y) + (VecA.z * SurfaceNrm.z)
    Result AS Vec3
    Result.x = (SurfaceNrm.x * Dot * 2.0) - VecA.x
    Result.y = (SurfaceNrm.y * Dot * 2.0) - VecA.y
    Result.z = (SurfaceNrm.z * Dot * 2.0) - VecA.z
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION prj3(Point      REF AS Vec3,                         // "Projection"  Get ClosestPointOnLine from 'Point'.
              LinePointA REF AS Vec3, LinePointB REF AS Vec3)
    Delta_AP_X AS FLOAT : Delta_AP_X = Point.x - LinePointA.x  // Point.x = ...  @@ Could reuse Point var here.
    Delta_AP_Y AS FLOAT : Delta_AP_Y = Point.y - LinePointA.y  // Point.y = ...
    Delta_AP_Z AS FLOAT : Delta_AP_Z = Point.z - LinePointA.z  // Point.z = ...

    Delta_AB_X AS FLOAT : Delta_AB_X = LinePointB.x - LinePointA.x  // LinePointB.x = ...  @@ Could reuse LinePointB var here.
    Delta_AB_Y AS FLOAT : Delta_AB_Y = LinePointB.y - LinePointA.y  // LinePointB.y = ...
    Delta_AB_Z AS FLOAT : Delta_AB_Z = LinePointB.z - LinePointA.z  // LinePointB.z = ...

    Dot_AP_AB            AS FLOAT : Dot_AP_AB            = (Delta_AP_X * Delta_AB_X) + (Delta_AP_Y * Delta_AB_Y) + (Delta_AP_Z * Delta_AB_Z)
    Delta_AB_Length_Sqrd AS FLOAT : Delta_AB_Length_Sqrd = (Delta_AB_X * Delta_AB_X) + (Delta_AB_Y * Delta_AB_Y) + (Delta_AB_Z * Delta_AB_Z)

    // Get PointDistance from NearestPointOnLine, as multiple of Delta_AB.
    Delta_Scalar AS FLOAT : Delta_Scalar = Dot_AP_AB / Delta_AB_Length_Sqrd // (LengthNew / LengthOld)

    Result AS Vec3
    Result.x = LinePointA.x + (Delta_AB_X * Delta_Scalar)
    Result.y = LinePointA.y + (Delta_AB_Y * Delta_Scalar)
    Result.z = LinePointA.z + (Delta_AB_Z * Delta_Scalar)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION prj3n(Point   REF AS Vec3,                      // "Projection"  Get ClosestPointOnLine from 'Point'.
               LinePos REF AS Vec3, LineNrm REF AS Vec3)
    Dot_AP_AB AS FLOAT : Dot_AP_AB = ((Point.x - LinePos.x) * LineNrm.x) + ((Point.y - LinePos.y) * LineNrm.y) + ((Point.z - LinePos.z) * LineNrm.z)
    Result AS Vec3
    Result.x = LinePos.x + (LineNrm.x * Dot_AP_AB)
    Result.y = LinePos.y + (LineNrm.y * Dot_AP_AB)
    Result.z = LinePos.z + (LineNrm.z * Dot_AP_AB)
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION AngleToVec3_OnPlnX(Theta AS FLOAT) // Axis X, 'Result' will be on plane spanning YZ.
    Theta = -Theta // Theta is inverted.
    Result AS Vec3
    Result.x =  0.0
    Result.y =  sin(Theta)
    Result.z = -cos(Theta)
ENDFUNCTION Result

FUNCTION AngleToVec3_OnPlnY(Theta AS FLOAT) // Axis Y, 'Result' will be on plane spanning XZ.
    Theta = -Theta // Theta is inverted.
    Result AS Vec3
    Result.x =  cos(Theta)
    Result.y = 0.0
    Result.z = -sin(Theta)
ENDFUNCTION Result

FUNCTION AngleToVec3_OnPlnZ(Theta AS FLOAT) // Axis Z, 'Result' will be on plane spanning XY.
    Theta = -Theta // Theta is inverted.
    Result AS Vec3
    Result.x = cos(Theta)
    Result.y = sin(Theta)
    Result.z = 0.0
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION PitchYawToVec3(Pch AS FLOAT, Yaw AS FLOAT)
    Result AS Vec3
    //  Theta & Z are inverted.
    //      (Pch= 0,Yaw= 0) = ( 0, 0,-1)
    //      (Pch=90,Yaw= 0) = ( 0,-1, 0)
    //      (Pch= 0,Yaw=90) = ( 1, 0, 0)
    Result.y =             cos( Pch )
    Result.x =  Result.y * sin( Yaw )
    Result.z = -Result.y * cos( Yaw )
    Result.y =            -sin( Pch ) // Actual Y value.
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION pch3(Point REF AS Vec3, Theta AS FLOAT) // "Rotate" 'Point' around Pivot(0,0,0) on AxisX.
    IF (Theta = 0.0)
        EXITFUNCTION Point
    ELSE
        Theta = -Theta // Theta is inverted.

        CosT AS FLOAT : CosT = cos(Theta)
        SinT AS FLOAT : SinT = sin(Theta)

        Result AS Vec3
        Result.x = Point.x                         //Result.x = 1.0*Point.x +  0.0*Point.y +   0.0*Point.z
        Result.y = CosT*Point.y + -SinT*Point.z    //Result.y = 0.0*Point.x + CosT*Point.y + -SinT*Point.z
        Result.z = SinT*Point.y +  CosT*Point.z    //Result.z = 0.0*Point.x + SinT*Point.y +  CosT*Point.z
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION pch3p(Point REF AS Vec3, Pivot REF AS Vec3, Theta AS FLOAT) // "Rotate" 'Point' around 'Pivot' on AxisX.
    IF (Theta = 0.0)
        EXITFUNCTION Point
    ELSE
        Theta = -Theta // Theta is inverted.

        Delta_X AS FLOAT : Delta_X = Point.x - Pivot.x
        Delta_Y AS FLOAT : Delta_Y = Point.y - Pivot.y
        Delta_Z AS FLOAT : Delta_Z = Point.z - Pivot.z

        CosT AS FLOAT : CosT = cos(Theta)
        SinT AS FLOAT : SinT = sin(Theta)

        Result AS Vec3
        Result.x = Pivot.x  +  Delta_X                         //Result.x = Pivot.x  +  1.0*Delta_X +  0.0*Delta_Y +   0.0*Delta_Z
        Result.y = Pivot.y  +  CosT*Delta_Y + -SinT*Delta_Z    //Result.y = Pivot.y  +  0.0*Delta_X + CosT*Delta_Y + -SinT*Delta_Z
        Result.z = Pivot.z  +  SinT*Delta_Y +  CosT*Delta_Z    //Result.z = Pivot.z  +  0.0*Delta_X + SinT*Delta_Y +  CosT*Delta_Z
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION yaw3(Point REF AS Vec3, Theta AS FLOAT) // "Rotate" 'Point' around Pivot(0,0,0) on AxisY.
    IF (Theta = 0.0)
        EXITFUNCTION Point
    ELSE
        Theta = -Theta // Theta is inverted.

        CosT AS FLOAT : CosT = cos(Theta)
        SinT AS FLOAT : SinT = sin(Theta)

        Result AS Vec3
        Result.x =  CosT*Point.x + SinT*Point.z    //Result.x =  CosT*Point.x + 0.0*Point.y + SinT*Point.z
        Result.y = Point.y                         //Result.y =   0.0*Point.x + 1.0*Point.y +  0.0*Point.z
        Result.z = -SinT*Point.x + CosT*Point.z    //Result.z = -SinT*Point.x + 0.0*Point.y + CosT*Point.z
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION yaw3p(Point REF AS Vec3, Pivot REF AS Vec3, Theta AS FLOAT) // "Rotate" 'Point' around 'Pivot' on AxisY.
    IF (Theta = 0.0)
        EXITFUNCTION Point
    ELSE
        Theta = -Theta // Theta is inverted.

        Delta_X AS FLOAT : Delta_X = Point.x - Pivot.x
        Delta_Y AS FLOAT : Delta_Y = Point.y - Pivot.y
        Delta_Z AS FLOAT : Delta_Z = Point.z - Pivot.z

        CosT AS FLOAT : CosT = cos(Theta)
        SinT AS FLOAT : SinT = sin(Theta)

        Result AS Vec3
        Result.x = Pivot.x  +   CosT*Delta_X + SinT*Delta_Z    //Result.x = Pivot.x  +   CosT*Delta_X + 0.0*Delta_Y + SinT*Delta_Z
        Result.y = Pivot.y  +  Delta_Y                         //Result.y = Pivot.y  +    0.0*Delta_X + 1.0*Delta_Y +  0.0*Delta_Z
        Result.z = Pivot.z  +  -SinT*Delta_X + CosT*Delta_Z    //Result.z = Pivot.z  +  -SinT*Delta_X + 0.0*Delta_Y + CosT*Delta_Z
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rol3(Point REF AS Vec3, Theta AS FLOAT) // "Rotate" 'Point' around Pivot(0,0,0) on AxisZ.
    IF (Theta = 0.0)
        EXITFUNCTION Point
    ELSE
        Theta = -Theta // Theta is inverted.

        CosT AS FLOAT : CosT = cos(Theta)
        SinT AS FLOAT : SinT = sin(Theta)

        Result AS Vec3
        Result.x = CosT*Point.x + -SinT*Point.y    //Result.x = CosT*Point.x + -SinT*Point.y + 0.0*Point.z
        Result.y = SinT*Point.x +  CosT*Point.y    //Result.y = SinT*Point.x +  CosT*Point.y + 0.0*Point.z
        Result.z = Point.z                         //Result.z =  0.0*Point.x +   0.0*Point.y + 1.0*Point.z
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rol3p(Point REF AS Vec3, Pivot REF AS Vec3, Theta AS FLOAT) // "Rotate" 'Point' around 'Pivot' on AxisZ.
    IF (Theta = 0.0)
        EXITFUNCTION Point
    ELSE
        Theta = -Theta // Theta is inverted.

        Delta_X AS FLOAT : Delta_X = Point.x - Pivot.x
        Delta_Y AS FLOAT : Delta_Y = Point.y - Pivot.y
        Delta_Z AS FLOAT : Delta_Z = Point.z - Pivot.z

        CosT AS FLOAT : CosT = cos(Theta)
        SinT AS FLOAT : SinT = sin(Theta)

        Result AS Vec3
        Result.x = Pivot.x  +  CosT*Delta_X + -SinT*Delta_Y    //Result.x = Pivot.x  +  CosT*Delta_X + -SinT*Delta_Y + 0.0*Delta_Z
        Result.y = Pivot.y  +  SinT*Delta_X +  CosT*Delta_Y    //Result.y = Pivot.y  +  SinT*Delta_X +  CosT*Delta_Y + 0.0*Delta_Z
        Result.z = Pivot.z  +  Delta_Z                         //Result.z = Pivot.z  +   0.0*Delta_X +   0.0*Delta_Y + 1.0*Delta_Z
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rot3(Point REF AS Vec3, Axis REF AS Vec3, Theta AS FLOAT) // "Rotate" 'Point' around Pivot(0,0,0) on 'Axis'.
    IF (Theta = 0.0)
        EXITFUNCTION Point
    ELSE
        Theta = -Theta // Theta is inverted.

        iCosT AS FLOAT : iCosT = 1.0-cos(Theta)
         CosT AS FLOAT :  CosT =     cos(Theta)
         SinT AS FLOAT :  SinT =     sin(Theta)

        Result AS Vec3
        Result.x = ( Point.x * (Axis.x*Axis.x*iCosT +        CosT) )  +  ( Point.y * (Axis.y*Axis.x*iCosT - Axis.z*SinT) )  +  ( Point.z * (Axis.z*Axis.x*iCosT + Axis.y*SinT) )
        Result.y = ( Point.x * (Axis.x*Axis.y*iCosT + Axis.z*SinT) )  +  ( Point.y * (Axis.y*Axis.y*iCosT +        CosT) )  +  ( Point.z * (Axis.z*Axis.y*iCosT - Axis.x*SinT) )
        Result.z = ( Point.x * (Axis.x*Axis.z*iCosT - Axis.y*SinT) )  +  ( Point.y * (Axis.y*Axis.z*iCosT + Axis.x*SinT) )  +  ( Point.z * (Axis.z*Axis.z*iCosT +        CosT) )
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rot3p(Point REF AS Vec3, Pivot REF AS Vec3, Axis REF AS Vec3, Theta AS FLOAT) // "Rotate" 'Point' around 'Pivot' on 'Axis'.
    IF (Theta = 0.0)
        EXITFUNCTION Point
    ELSE
        Theta = -Theta // Theta is inverted.

        Delta_X AS FLOAT : Delta_X = Point.x - Pivot.x
        Delta_Y AS FLOAT : Delta_Y = Point.y - Pivot.y
        Delta_Z AS FLOAT : Delta_Z = Point.z - Pivot.z

        iCosT AS FLOAT : iCosT = 1.0-cos(Theta)
         CosT AS FLOAT :  CosT =     cos(Theta)
         SinT AS FLOAT :  SinT =     sin(Theta)

        Result AS Vec3
        Result.x = Pivot.x  +  ( Delta_X * (Axis.x*Axis.x*iCosT +        CosT) )  +  ( Delta_Y * (Axis.y*Axis.x*iCosT - Axis.z*SinT) )  +  ( Delta_Z * (Axis.z*Axis.x*iCosT + Axis.y*SinT) )
        Result.y = Pivot.y  +  ( Delta_X * (Axis.x*Axis.y*iCosT + Axis.z*SinT) )  +  ( Delta_Y * (Axis.y*Axis.y*iCosT +        CosT) )  +  ( Delta_Z * (Axis.z*Axis.y*iCosT - Axis.x*SinT) )
        Result.z = Pivot.z  +  ( Delta_X * (Axis.x*Axis.z*iCosT - Axis.y*SinT) )  +  ( Delta_Y * (Axis.y*Axis.z*iCosT + Axis.x*SinT) )  +  ( Delta_Z * (Axis.z*Axis.z*iCosT +        CosT) )
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION rot3m(Point REF AS Vec3, ThetaVec REF AS Vec3) // "Rotate" 'Point' around Pivot(0,0,0) on multiple axes.     // Simultaneous Multi-Axis Angular Rotation.
    IF (ThetaVec.x = 0.0 AND ThetaVec.y = 0.0 AND ThetaVec.z = 0.0)
        EXITFUNCTION Point
    ELSE
        // Derive singular rotation 'Theta'. (Length of 'ThetaVec'.)
        Theta AS FLOAT : Theta = -sqrt(ThetaVec.x*ThetaVec.x + ThetaVec.y*ThetaVec.y + ThetaVec.z*ThetaVec.z) // Theta is inverted.

        // Derive singular rotation 'Axis'. ('ThetaVec' normalized.)
        ThetaRcp AS FLOAT : ThetaRcp = 1.0 / Theta
        Axis AS Vec3
        Axis.x = ThetaVec.x * ThetaRcp
        Axis.y = ThetaVec.y * ThetaRcp
        Axis.z = ThetaVec.z * ThetaRcp

        iCosT AS FLOAT : iCosT = 1.0-cos(Theta) // "Complimentary-Inverse Cosine-Theta".
         CosT AS FLOAT :  CosT =     cos(Theta)
         SinT AS FLOAT :  SinT =     sin(Theta)

        Result AS Vec3
        Result.x = ( Point.x * (Axis.x*Axis.x*iCosT +        CosT) )  +  ( Point.y * (Axis.y*Axis.x*iCosT - Axis.z*SinT) )  +  ( Point.z * (Axis.z*Axis.x*iCosT + Axis.y*SinT) )
        Result.y = ( Point.x * (Axis.x*Axis.y*iCosT + Axis.z*SinT) )  +  ( Point.y * (Axis.y*Axis.y*iCosT +        CosT) )  +  ( Point.z * (Axis.z*Axis.y*iCosT - Axis.x*SinT) )
        Result.z = ( Point.x * (Axis.x*Axis.z*iCosT - Axis.y*SinT) )  +  ( Point.y * (Axis.y*Axis.z*iCosT + Axis.x*SinT) )  +  ( Point.z * (Axis.z*Axis.z*iCosT +        CosT) )
    ENDIF
ENDFUNCTION Result


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION bulkrot3p(Points REF AS Vec3[], Pivot REF AS Vec3, Axis REF AS Vec3, Theta AS FLOAT)
    // TODO.
    // Rotate Array of Points.
ENDFUNCTION

